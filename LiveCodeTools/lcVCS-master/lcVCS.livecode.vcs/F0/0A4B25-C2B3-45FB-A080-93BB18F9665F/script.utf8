/**
 *  This file is part of lcVCS (C) 2013 M E R Goulding.
 *  
 *  lcVCS is free software: you can redistribute it and/or modify
 *  it under the terms of the GNU General Public License as published by
 *  the Free Software Foundation, either version 3 of the License, or
 *  (at your option) any later version.
 *  
 *  lcVCS is distributed in the hope that it will be useful,
 *  but WITHOUT ANY WARRANTY; without even the implied warranty of
 *  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *  GNU General Public License for more details.
 *  
 *  You should have received a copy of the GNU General Public License
 *  along with lcVCS.  If not, see <http://www.gnu.org/licenses/>.
 */

/**
*  This file is part of lcVCS (C) 2013 M E R Goulding.
*  
*  lcVCS is free software: you can redistribute it and/or modify
*  it under the terms of the GNU General Public License as published by
*  the Free Software Foundation, either version 3 of the License, or
*  (at your option) any later version.
*  
*  lcVCS is distributed in the hope that it will be useful,
*  but WITHOUT ANY WARRANTY; without even the implied warranty of
*  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
*  GNU General Public License for more details.
*  
*  You should have received a copy of the GNU General Public License
*  along with lcVCS.  If not, see <http://www.gnu.org/licenses/>.
*/


constant kUnicodeProps = "unicodeTitle,unicodeLabel,unicodeToolTip,unicodeText"
constant kIconProps = "icon,hiliteIcon,disabledIcon,visitedIcon,armedIcon,hoverIcon"
constant kPatternProps = "forePattern,focusPattern,backPattern,borderPattern,bottomPattern,hilitePattern,shadowPattern,topPattern"
constant kExtension = "vcs"
constant kPropsToDelete = "defaultButton,armed,layer"
constant kPasswordProtectedStackPrefix = "34f35cd6-e2fb-4d4e-a93a-bcd12b40a930"

local sUUIDMap -- an array with UUIDs as keys and object references as values
local sUUIDsToResolve -- object references are resolved once the stackFile is fully imported
local sConflicts -- conflict markers are parsed and the plugin assists resolution
local sPropsToSet -- properties that need to be set right at the end eg cantModify of stack
local sStacksToDelete -- stacks to delete after the import
local sCurrentStackFilePath -- the path to the stackFile currently being imported
local sPluginsA -- an array with loaded plugins for UUID resolution and unnecessary custom property filtering
local sTempNameSuffix -- a suffix (uuid) used when lcVCS is importing itself
local sStackPath -- the path to the stack being imported
local sMainstackPath -- the path to the mainstack being imported
local sSharedGroup -- keeps track of imported shared groups in a stack
local sUnsharedProps -- holds unshared data of shared objects until the group is placed
local sOldUmask -- holds the original umask property on linux so it can be set back

--on libraryStack
--   SetBehaviorForVersion
--end libraryStack

--command SetBehaviorForVersion
--   set the itemDel to "."
--   if item 1 of the version < 7 then
--      set the behavior of btn "common" of cd 1 of me to the long id of btn "LC 6" of cd 1 of me
--   else
--      set the behavior of btn "common" of cd 1 of me to the long id of btn "LC 7" of cd 1 of me
--   end if
--end SetBehaviorForVersion

# Use the optional pStackFile parameter to export only one stackFile from
# a project. This should only be done if there is a plugin resetting
# the UUIDs of objects after a stack clone (and ideally after other object copies).
command ExportProject pFilePath,pStackFile
   local tMainstacks
   put the mainstacks into tMainstacks
   
   SetUMask
   
   local tProject
   start using me
   delete variable sUUIDMap
   lock messages
   put ResolveProjectFile(pFilePath) into tProject
   LoadPlugins tProject["plugins"]
   set the itemDel to slash
   repeat with tIndex = 1 to the number of elements of tProject["stackFiles"]
      # ensure all stacks are loaded into memory even if only exporting one file
      if there is a stack tProject["imported stackfiles"][tIndex] and \
            (pStackFile is empty or tProject["imported stackfiles"][tIndex] is pStackFile) then
         EnsureFolder tProject["exported stackfiles"][tIndex]
         ExportStackFile tProject["imported stackfiles"][tIndex], tProject["exported stackfiles"][tIndex]
      end if
   end repeat
   UnloadPlugins
   
   # Remove stacks from memory if they weren't in memory prior to export
   lock messages
   repeat with tIndex = 1 to the number of elements of tProject["imported stackFiles"]
      if the short name of stack tProject["imported stackFiles"][tIndex] is not among the lines of tMainstacks then
         delete stack tProject["imported stackFiles"][tIndex]
      end if
   end repeat
   unlock messages
   
   stop using me
   
   UnsetUMask
end ExportProject

command SetUmask
   if the platform is "linux" then
      put the umask into sOldUmask
      set the umask to baseConvert("133",8,10)
   end if
end SetUmask

command UnsetUmask
   if the platform is "linux" then
      set the umask to sOldUmask
   end if
end UnsetUmask


command ImportProject pFilePath
   local tCaseSensitve,tProject,tIsLcVCS
   
   start using me
   
   lock messages
   
   delete variable sUUIDMap
   LoadDataGridUUIDs
   delete variable sConflicts
   delete variable sStacksToDelete
   delete variable sSharedGroup
   put UUID() into sTempNameSuffix
   
   put ResolveProjectFile(pFilePath) into tProject
   LoadPlugins tProject["plugins"]
   
   set the itemDel to slash
   put tProject["name"] = "lcVCS" and the environment is "development" into tIsLcVCS
   
   repeat with tIndex = 1 to the number of elements of tProject["stackFiles"]
      EnsureFolder item 1 to -2 of tProject["imported stackFiles"][tIndex]
      ImportStackFile tProject["exported stackFiles"][tIndex], tProject["imported stackFiles"][tIndex], tIsLcVCS
   end repeat
   
   repeat for each key tStack in sStacksToDelete
      set the cantDelete of stack tStack to false
      delete stack tStack
   end repeat
   
   unlock messages
   
   if tIsLcVCS then
      send "PostImportStack sTempNameSuffix" to stack ("lcVCS"&sTempNameSuffix) in 0 milliseconds
   end if
   
   UnloadPlugins
   
   stop using me
end ImportProject

function ResolveProjectFile pFilePath
   local tProject,tProjectPath
   
   put JSONToArray(url ("binfile:"&pFilePath)) into tProject
   
   # get project file path for relative path resolution
   set the itemDelimiter to slash
   put item 1 to -2 of pFilePath into tProjectPath
   if char -1 of tProjectPath is not slash then
      put slash after tProjectPath
   end if
   
   put merge(tProject["build path"]) into tProject["build path"]
   
   # resolve relative path
   if there is not a folder tProject["build path"] then
      put tProjectPath before tProject["build path"]
   end if
   
   if char -1 of tProject["build path"] is not slash then
      put slash after tProject["build path"]
   end if
   
   repeat for each key tIndex in tProject["stackFiles"]
      put tProjectPath & tProject["stackFiles"][tIndex] & "." & kExtension into tProject["exported stackFiles"][tIndex]
      put tProject["build path"] & tProject["stackFiles"][tIndex] into tProject["imported stackFiles"][tIndex]
   end repeat
   
   local tResources,tPath
   put merge(tProject["resource paths"]) into tResources
   repeat for each line tPath in tResources
      
      # check if it's a full path to a stackfile which loads it anyway
      if there is a stack tPath then
         next repeat
      end if
      
      # resolve relative path
      if there is not a folder tPath then
         put tProjectPath before tPath
         if there is a folder tPath then
            # work around the engine not resolving the file path 
            # before throwing an error about duplicate file names
            put the folder into tOldFolder
            set the folder to tPath
            put the folder into tPath
            set the folder to tOldFolder
         end if
      end if
      
      # check if it's a full path to a stackfile which loads it anyway
      if there is a stack tPath then
         next repeat
      end if
      
      if there is a folder tPath then
         LoadStackFilesRecursively tPath
      else
         put "Could not resolve resource path: "&tPath&cr after msg
      end if
      
   end repeat
   
   return tProject
end ResolveProjectFile

private command LoadStackFilesRecursively pPath
   local tOldFolder,tFolder,tFile
   
   put the folder into tOldFolder
   
   if there is a folder pPath then
      
      set the folder to pPath
      
      # recurse over folders
      repeat for each line tFolder in the folders
         if char 1 of tFolder is not "." then
            LoadStackFilesRecursively pPath & slash & tFolder
         end if
      end repeat
      
      # load stackFiles into memory
      repeat for each line tFile in the files
         if char 1 of tFile is not "." then
            get there is a stack (pPath & slash & tFile)
         end if
      end repeat
      
   end if
   
   set the folder to tOldFolder
end LoadStackFilesRecursively

# Export the stackfile. Creates a directory at the same path as the stackfile&.kExtension
command ExportStackFile pFilePath,pFolder
   local tFolder,tStacks,tSubstacks,tIndex,tOriginalFolder
   
   lock screen
   put the folder into tOriginalFolder
   if there is a stack pFilePath then
      -- mainstack
      if pFolder is empty then
         put pFilePath into tFolder
         put "."&kExtension after tFolder
      else
         if there is a folder pFolder then
            put pFolder into tFolder
         else -- relative path
            put pFilePath into tFolder
            set the itemDel to slash
            put pFolder into item -1 of tFolder
         end if
      end if
      revDeleteFolder tFolder
      create folder tFolder
      set the folder to tFolder
      put tFolder into sMainstackPath
      put UUIDForObject(the long id of stack the mainstack of stack pFilePath) into url "file:mainstack"
      ExportStack the mainstack of stack pFilePath
      save stack pFilePath
   end if
   set the folder to tOriginalFolder
end ExportStackFile

# Import a stackfile from a folder
on ImportStackFile pFolder,pFilePath,pIslcVCS
   local tUUIDSearchDone = "false",tOriginalFolder,tStackFileMainstack,tUUIDs,tMainstackUUID
   lock screen
   lock messages
   put pFilePath into sCurrentStackFilePath
   
   if sCurrentStackFilePath is empty then
      put pFolder into sCurrentStackFilePath
      set the itemDel to "."
      if item -1 of sCurrentStackFilePath = "vcs" then
         delete item -1 of sCurrentStackFilePath
      end if
   else
      set the itemDel to slash
      if there is not a folder (item 1 to -2 of sCurrentStackFilePath) then
         if char -1 of pFolder is "/" then
            delete char -1 of pFolder
         end if
         put pFolder&"/" before sCurrentStackFilePath
      end if
   end if
   
   put the folder into tOriginalFolder
   delete variable sUUIDsToResolve
   delete variable sPropsToSet
   delete variable sUnsharedProps
   set the folder to pFolder
   put pFolder into sMainstackPath
   put url "file:mainstack" into tMainstackUUID
   if tMainstackUUID is empty then
      return "no mainstack file found"
   end if
   set the folder to UUIDToObjectPath(tMainstackUUID)
   ImportObject "","","",pIslcVCS
   put the short name of sUUIDMap[tMainstackUUID] into tStackFileMainstack
   -- only load UUIDs from all mainstacks if necessary
   repeat for each key tObject in sUUIDsToResolve
      repeat for each key tProperty in sUUIDsToResolve[tObject] 
         repeat for each line tUUID in sUUIDsToResolve[tObject][tProperty]
            -- resolve UUID references (icons, patterns, behaviors)
            -- load UUIDs from all mainstacks only if required
            if tUUID is not an integer and not tUUIDSearchDone and there is not a sUUIDMap[tUUID] then
               put "searching for: "&tStackFileMainstack&tab&tObject&tab&tProperty&tab&sUUIDMap[tUUID]&tab&tUUID&cr after msg
               put true into tUUIDSearchDone
               repeat for each line tMainstack in the mainstacks
                  repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
                     repeat with tCard = 1 to the number of cards of stack tStack
                        -- parse all controls
                        local tControlUUID
                        repeat with tControl =1 to the number of controls of card tCard of stack tStack
                           put the uVersion["UUID"] of control tControl of card tCard of stack tStack into tControlUUID
                           if tControlUUID <> "" then
                              put the long id of control tControl of card tCard of stack tStack into sUUIDMap[tControlUUID]
                           end if
                        end repeat
                     end repeat
                  end repeat
               end repeat
            end if
         end repeat
         
         local tUUIDResolved
         put false into tUUIDResolved
         
         repeat for each key tIndex in sPluginsA["sets"][tProperty]
            if there is a stack sPluginsA["sets"][tProperty][tIndex]["stack"] then
               dispatch "lcVCSResolveUUIDs" to stack sPluginsA["sets"][tProperty][tIndex]["stack"] with tObject
               put true into tUUIDResolved
            end if
         end repeat
         
         repeat for each key tIndex in sPluginsA["keys"][tProperty]
            if there is a stack sPluginsA["keys"][tProperty][tIndex]["stack"] then
               dispatch "lcVCSResolveUUIDs" to stack sPluginsA["keys"][tProperty][tIndex]["stack"] with tObject
               put true into tUUIDResolved
            end if
         end repeat
         
         if not tUUIDResolved then
            if there is a sUUIDMap[tUUID] then
               switch 
                  case tProperty is "behavior"
                     replace sTempNameSuffix with empty in sUUIDMap[tUUID]
                     set the tProperty of tObject to sUUIDMap[tUUID]
                     break
                  default
                     set the tProperty of tObject to the short id of sUUIDMap[tUUID]
                     break
               end switch
            else
               try -- could be some object that wasn't in memory during the export so it's not a UUID
                  set the tProperty of tObject to tUUID
               end try
            end if
         end if
      end repeat
   end repeat
   
   if pIslcVCS then
      -- engine can not cope with two stacks having the same filename
      set the fileName of stack tStackFileMainstack to sCurrentStackFilePath
   end if
   
   -- set cant modify
   repeat for each key tProperty in sPropsToSet
      repeat for each key tObject in sPropsToSet[tProperty]
         set the tProperty of tObject to sPropsToSet[tProperty][tObject]
      end repeat
   end repeat
   save stack tStackFileMainstack
   if not pIslcVCS then
      put "" into sStacksToDelete[tStackFileMainstack]
   end if
   
   set the folder to tOriginalFolder
end ImportStackFile

-- if the stack gets this message then it just 
-- imported a version of itself with a temp name
on PostImportStack pTempNameSuffix
   local tMainstacks,tStack,tStackName
   put the mainstacks into tMainstacks
   filter tMainstacks with "*"&pTempNameSuffix
   repeat for each line tMainstack in tMainstacks
      repeat for each line tStack in tMainstack&cr&the substacks of stack tMainstack
         -- delete stacks (remove stackfile from memory)
         put tStack into tStackName
         replace pTempNameSuffix with empty in tStackName
         if there is a stack tStackName then
            set the cantDelete of stack tStackName to false
            delete stack tStackName
         end if
         -- set names correctly
         set the name of stack tStack to tStackName
         save stack tStackName
      end repeat
   end repeat
   -- funky stuff in order to reload lcVCS in memory
   create invisible stack "lcVCSLoader"
   set the script of stack "lcVCSLoader" to \
         format("on ReloadlcVCS\ndelete stack \"lcVCS\"\ngo stack revEnvironmentUserPluginsPath()&\"/lcVCS.livecode\"\nend ReloadlcVCS")
   send "ReloadlcVCS" to stack "lcVCSLoader" in 0 milliseconds
end PostImportStack


on ImportObject pStackUUID,pCardUUID,pParentUUID,pIslcVCS
   local tObject,tSetName,tType,tError,tConflict="false",tResize,tUUIDS,tStackPath,tUserState,tScript,tVersion,tOriginalFolder
   if there is a stack "stack.binary" then
      # clean the name
      local tName
      put the short name of stack "stack.binary" into tName
      replace kPasswordProtectedStackPrefix with empty in tName
      set the name of stack "stack.binary" to tName
      
      # set the mainstack of substacks
      if pStackUUID is not empty then
         set the mainstack of stack tName to the short name of sUUIDMap[pStackUUID]
      end if
      
      put CleanLayerFile(url "file:substacks") into tUUIDs
      
      put UUIDForObject(the long id of stack tName) into pStackUUID
      
      LoadUUIDs the long id of stack tName
      
      repeat for each line tUUID in tUUIDs
         if sUUIDMap[tUUID] is empty then
            set the folder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
            ImportObject pStackUUID
         end if
      end repeat
   else
      put url ("binfile:properties.json") into tObject
      if tObject is not empty then
         try
            put JSONToArray(tObject) into tObject["A"]
         catch tError
            -- most likely there's conflict markers causing an issue or someone's bad manual edit...
            put ParseConflictedFile(tObject) into tObject
            try
               put JSONToArray(tObject["A"]) into tObject["A"]
               put JSONToArray(tObject["B"]) into tObject["B"]
               #! reinstate when union recursively is released
               --         -- make sure it's a real difference in an element value not 
               --         -- just the two branches adding to the last item of the same JSON object (trailing comma issue)
               --         -- union will add elements from one object to another but won't mess with existing elements
               --         union tObject["A"] with tObject["B"] recursively
               --         union tObject["B"] with tObject["A"] recursively
               --         -- if the arrays are now the same then we know it was just a trailing comma issue
               --         if tObject["A"] is tObject["B"] then
               --            delete variable tObject["B"]
               --         end if
            catch tError
               answer "There was an error decoding properties file:"&cr&the folder&"/properties.json"&cr&tError
               exit to top
            end try
         end try
         if there is a file "userstate.json" then
            try
               #! modify when union recursively is released
               put JSONToArray(url ("userstate.json")) into tUserState
               repeat for each key tCustomPropertySet in tUserState
                  union tObject["A"]["customPropertySets"][tCustomPropertySet] with tUserState[tCustomPropertySet] 
               end repeat
               if tObject["B"] is an array then
                  repeat for each key tCustomPropertySet in tUserState
                     union tObject["B"]["customPropertySets"][tCustomPropertySet] with tUserState[tCustomPropertySet] 
                  end repeat
               end if
            end try
         end if
         put NativeToUTF8(tObject["A"]["properties"]["name"]) into tObject["A"]["properties"]["name"]
         switch tObject["A"]["class"]
            case "com.runrev.engine.stack"
               put the folder into sStackPath
               -- support VCS on self
               if pIslcVCS then
                  create stack (tObject["A"]["properties"]["name"]&sTempNameSuffix)
               else
                  if there is a stack tObject["A"]["properties"]["name"] then
                     set the cantDelete of stack tObject["A"]["properties"]["name"] to false
                     delete stack tObject["A"]["properties"]["name"]
                  end if
                  create stack tObject["A"]["properties"]["name"]
               end if
               set the defaultStack to it
               set the loc of it to the screenLoc
               -- workaround for the fact that the first card is already created
               -- and we use this for a background creation card
               -- a new stack id is always 1002 so the id of 1000 will be safe
               set the id of card 1 of it to 1000
               if pStackUUID is not empty then
                  set the mainstack of it to the short name of sUUIDMap[pStackUUID]
               else if not pIslcVCS then
                  -- engine can not cope with two stacks having the same filename
                  set the fileName of it to sCurrentStackFilePath
               end if
               put tObject["A"]["UUID"] into pStackUUID
               break
            case "com.runrev.engine.card"
               create card tObject["A"]["properties"]["name"]
               put tObject["A"]["UUID"] into pCardUUID
               break
            case "com.runrev.engine.image"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create image tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create image tObject["A"]["properties"]["name"]
               end if
               if there is a file ("image."&tObject["A"]["properties"]["paintCompression"]) then
                  set the text of it to url ("binfile:image."&tObject["A"]["properties"]["paintCompression"])
               end if
               delete variable tObject["A"]["properties"]["paintCompression"]
               if tObject["A"]["properties"]["fileName"] is empty then
                  delete variable tObject["A"]["properties"]["fileName"]
               end if
               break
            case "com.runrev.engine.button"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create button tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create button tObject["A"]["properties"]["name"]
               end if
               reset the templateButton
               break
            case "com.runrev.engine.field"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create field tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create field tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.player"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create player tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create player tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.scrollbar"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create scrollbar tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create scrollbar tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.graphic"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create graphic tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create graphic tObject["A"]["properties"]["name"]
               end if
               break
            case "com.runrev.engine.group"
               if word 1 of sUUIDMap[pParentUUID] is "group" then
                  create group tObject["A"]["properties"]["name"] in sUUIDMap[pParentUUID]
               else
                  create group tObject["A"]["properties"]["name"]
               end if
               set the lockUpdates of it to true
               break
            case "com.runrev.engine.widget"
               SetWidgetProperties tObject, sUUIDMap[pParentUUID]
               get the result
               break
            default
               ##! TODO
               -- custom control so find appropriate template object
               -- copy it to the appropriate spot
               
               break
         end switch
         if tObject["A"]["class"] <> "com.runrev.engine.stack" then
            put the abbrev id of it &" of "& sUUIDMap[pStackUUID] into sUUIDMap[tObject["A"]["UUID"]]
         else
            put it into sUUIDMap[tObject["A"]["UUID"]]
         end if
         set the itemDel to comma
         SetObjectProperties tObject["A"],pCardUUID,true
         put NativeFromUTF8(url ("binfile:script.utf8")) into tScript
         
         repeat for each key tIndex in sPluginsA["script"]
            if there is a stack sPluginsA["script"][tIndex] then
               dispatch "lcVCSFilterImportedScript" to stack sPluginsA["script"][tIndex] with sUUIDMap[tObject["A"]["UUID"]],tScript
            end if
         end repeat
         
         set the script of sUUIDMap[tObject["A"]["UUID"]] to tScript
         -- conflict resolution
         if the result contains "<<<<<<<" then
            -- script compilation error caused by conflict markers
            AddToConflicts sUUIDMap[tObject["A"]["UUID"]],"script"
            put true into tConflict
         end if
         if tObject["B"] is an array then
            AddToConflicts sUUIDMap[tObject["A"]["UUID"]],"properties",tObject
            put true into tConflict
         end if
         
         # set uVersion custom property set
         put tObject["A"]["UUID"] into tVersion["UUID"]
         put the short id of sUUIDMap[tObject["A"]["UUID"]] into tVersion["ID"]
         repeat for each key tKey in tVersion
            set the uVersion[tKey] of sUUIDMap[tObject["A"]["UUID"]] to tVersion[tKey]
         end repeat
         
         if tObject["A"]["class"] <> "com.runrev.engine.stack" then
            put CleanLayerFile(url "file:layers") into tUUIDs
            
            local tSharedGroupsOnCard
            repeat for each line tUUID in tUUIDs
               if sSharedGroup[tUUID] then
                  if not tSharedGroupsOnCard[tUUID] then
                     try
                        place sUUIDMap[tUUID] onto sUUIDMap[pCardUUID]
                     end try
                     -- sharedGroups are already created and just need to be relayered to front
                     relayer sUUIDMap[tUUID] to front of sUUIDMap[pCardUUID]
                     put true into tSharedGroupsOnCard[tUUID]
                  end if
               else
                  if sUUIDMap[tUUID] is empty then
                     set the folder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
                     ImportObject pStackUUID,pCardUUID,tObject["A"]["UUID"],pIslcVCS
                  end if
               end if
            end repeat
            
            if tObject["A"]["class"] is "com.runrev.engine.card" then
               -- remove unplaced groups
               repeat for each key tUUID in sSharedGroup
                  if not tSharedGroupsOnCard[tUUID] then
                     remove sUUIDMap[tUUID] from sUUIDMap[tObject["A"]["UUID"]]
                  end if
               end repeat
               
               # set unshared properties of shared object
               repeat for each key tUUID in sUnsharedProps[tObject["A"]["UUID"]]
                  local tControlRef -- reference to object on this card
                  put the abbrev id of sUUIDMap[tUUID] && "of" && sUUIDMap[tObject["A"]["UUID"]] into tControlRef
                  repeat for each key tProperty in sUnsharedProps[tObject["A"]["UUID"]][tUUID]
                     set the tProperty of tControlRef to sUnsharedProps[tObject["A"]["UUID"]][tUUID][tProperty]
                  end repeat
               end repeat
            end if
            
            if tObject["A"]["class"] is "com.runrev.engine.group" then
               set the lockUpdates of sUUIDMap[tObject["A"]["UUID"]] to false
            end if
            
         else
            # if the stack was password protected it may still have substacks
            put the folder into tOriginalFolder
            repeat for each item tType in "sharedGroups,cards,substacks"
               put CleanLayerFile(url ("file:"&tType)) into tUUIDs
               
               repeat for each line tUUID in tUUIDs
                  if sUUIDMap[tUUID] is empty then
                     set the folder to sMainstackPath & slash & UUIDToObjectPath(tUUID)
                     ImportObject pStackUUID,pCardUUID,,pIslcVCS
                     if tType is "sharedGroups" then
                        remove sUUIDMap[tUUID] from card 1
                     end if
                  end if
               end repeat
               
               switch tType
                  case "cards"
                     delete card 1
                     close this stack
                     break
               end switch
               
               set the folder to tOriginalFolder
            end repeat
         end if
      end if
   end if
   return pStackUUID
end ImportObject


command SetObjectProperties pProperties,pCardUUID,pDontSetNames
   local tOwner,tUUIDsToResolve,tCurrentProps,tFirstCard,tSharedGroup,tAbbrevID,tControlRef
   set the caseSensitive to true
   if pDontSetNames then
      delete variable pProperties["properties"]["name"]
   end if
   # clean the properties array
   -- set id first so it's already set when working out the UUIDs to resolve
   try
      if pProperties["properties"]["id"] is not empty then
         set the id of sUUIDMap[pProperties["UUID"]] to pProperties["properties"]["id"]
         put pProperties["properties"]["id"] into word 3 of sUUIDMap[pProperties["UUID"]]
      end if
   catch e
      put "ID conflict: "&&pProperties["properties"]["id"]&cr& \
            "Changed to: "&&the id of the long name of sUUIDMap[pProperties["UUID"]]&&the long name of sUUIDMap[pProperties["UUID"]]&cr after msg
   end try
   delete variable pProperties["properties"]["id"]
   put the properties of sUUIDMap[pProperties["UUID"]] into tCurrentProps
   
   if pProperties["properties"]["sharedBehavior"] then
      put true into sSharedGroup[pProperties["UUID"]]
   end if
   
   
   repeat for each key tProperty in pProperties["properties"]
      switch
         case tProperty is "resizable"
            set the resizable of sUUIDMap[pProperties["UUID"]] to false
         case tProperty is "cantModify"
            put pProperties["properties"][tProperty] into sPropsToSet[tProperty][sUUIDMap[pProperties["UUID"]]]
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is "hilitedButton"
            if pProperties["properties"][tProperty] is an integer then
               put pProperties["properties"][tProperty] into sPropsToSet[tProperty][sUUIDMap[pProperties["UUID"]]]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case tProperty is among the items of kIconProps,kPatternProps
         case tProperty is "behavior"
            -- store the value 
            if pProperties["properties"][tProperty] <> "" and pProperties["properties"][tProperty] <> 0 then
               put pProperties["properties"][tProperty] into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tProperty]
            end if
            delete variable pProperties["properties"][tProperty]
            break
         case char 1 to 7 of tProperty is "unicode" -- "unicode"&tProperty
            -- utf8 encoded
            put UnicodeFromUTF8(pProperties["properties"][tProperty]) into pProperties["properties"][tProperty]
            break
         case tProperty is "showController" -- showController precedence
            set the showController of sUUIDMap[pProperties["UUID"]] to pProperties["properties"][tProperty]
            break
         case tProperty is among the items of "htmlText,hilite"
            if pProperties["properties"][tProperty] is an array then
               put the abbrev id of sUUIDMap[pProperties["UUID"]] into tAbbrevID
               repeat for each key tUUID in pProperties["properties"][tProperty]
                  put pProperties["properties"][tProperty][tUUID] into sUnsharedProps[tUUID][pProperties["UUID"]][tProperty]
               end repeat
            end if
         case tProperty is "repeatCount" -- possible side effects of deleting
         case tProperty is "showBorder" -- side effects of deleting
            break
         case tProperty is "widget"
            delete variable pProperties["properties"][tProperty]
            break
         default
            if pProperties["properties"][tProperty] is tCurrentProps[tProperty] then
               delete variable pProperties["properties"][tProperty]
            else if pProperties["properties"][tProperty] is not a number and pProperties["properties"][tProperty] is not an array then
               put NativeFromUTF8(pProperties["properties"][tProperty]) into pProperties["properties"][tProperty]
            end if
            break
      end switch
   end repeat
   
   # now we can set the cleaned properties array
   set the properties of sUUIDMap[pProperties["UUID"]] to pProperties["properties"]
   
   repeat for each key tCustomPropertySet in pProperties["customPropertySets"]
      if tCustomPropertySet is "customKeys" then
         set the customProperties[""] of sUUIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
         repeat for each key tCustomProperty in pProperties["customPropertySets"][tCustomPropertySet]
            repeat for each key tIndex in sPluginsA["keys"][tCustomProperty]
               if sPluginsA["keys"][tCustomProperty][tIndex]["resolve UUIDs"] then
                  dispatch "lcVCSRegisterUUIDsToResolve" to stack sPluginsA["keys"][tCustomProperty][tIndex]["stack"] with sUUIDMap[pProperties["UUID"]],tUUIDsToResolve
                  if tUUIDsToResolve is not empty then
                     put tUUIDsToResolve into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tCustomProperty]
                  end if
                  delete variable tUUIDsToResolve
               end if 
            end repeat
         end repeat
      else
         set the customProperties[NativeToUTF8(tCustomPropertySet)] of sUUIDMap[pProperties["UUID"]] to pProperties["customPropertySets"][tCustomPropertySet]
         repeat for each key tIndex in sPluginsA["sets"][tCustomPropertySet]
            if sPluginsA["sets"][tCustomPropertySet][tIndex]["resolve UUIDs"] then
               dispatch "lcVCSRegisterUUIDsToResolve" to stack sPluginsA["sets"][tCustomPropertySet][tIndex]["stack"] with sUUIDMap[pProperties["UUID"]],tUUIDsToResolve
               if tUUIDsToResolve is not empty then
                  put tUUIDsToResolve into sUUIDsToResolve[sUUIDMap[pProperties["UUID"]]][tCustomPropertySet]
               end if
               delete variable tUUIDsToResolve
            end if 
         end repeat
      end if
   end repeat
   
end SetObjectProperties

private command LoadUUIDs pObject
   put pObject into sUUIDMap[UUIDForObject(pObject)]
   
   local tID,tSharedGroups
   switch word 1 of pObject
      case "stack"
         repeat for each line tID in the cardIDs of pObject
            LoadUUIDs "card id "&tID&" of "&pObject
         end repeat
         repeat for each line tID in the sharedGroupIDs of pObject
            LoadUUIDs "bkgnd id "&tID&" of "&pObject
         end repeat
         break
      case "card"
         put the sharedGroupIDs of pObject into tSharedGroups
         split tSharedGroups by row as set
      case "group"
      case "bkgnd"
         repeat for each line tID in the childControlIDs of pObject
            if not tSharedGroups[tID] then
               LoadUUIDs the long id of ("control id "&tID&" of "&pObject)
            end if
         end repeat
         break
   end switch
end LoadUUIDs

command AddToConflicts pObject,pType,pProperties
   put true into sConflicts[sCurrentStackFilePath][pObject][pType] 
   if pType = "properties" then
      put pProperties into sConflicts[sCurrentStackFilePath][pObject]["propertiesdata"]
   end if
end AddToConflicts

function GetConflicts
   return sConflicts
end GetConflicts

function UUIDForObject pObject
   local tVersion
   # ensure uniqueness of UUID in project
   if not exists(pObject) then return empty
   put the customProperties["uVersion"] of pObject into tVersion
   if tVersion["UUID"] = "" or \
         (word 1 of pObject is not "stack" and the short id of pObject <> tVersion["ID"]) or \
         (sUUIDMap[tVersion["UUID"]] is not empty and \
         the long id of sUUIDMap[tVersion["UUID"]] is not the long id of pObject) then
      put UUID() into tVersion["UUID"]
      put the short id of pObject into tVersion["ID"]
      repeat for each key tKey in tVersion
         set the uVersion[tKey] of pObject to tVersion[tKey]
      end repeat

      put the long id of pObject into sUUIDMap[tVersion["UUID"]]
   end if
   return tVersion["UUID"]
end UUIDForObject



function ObjectForUUID pUUID
   if exists(sUUIDMap[pUUID]) then
      get the long id of sUUIDMap[pUUID]
      replace sTempNameSuffix with empty in it
      return it
   else
      return ""
   end if
end ObjectForUUID

command ExportStack pStack
   local tIndex,tIsOpen,tObjectPath
   delete variable sSharedGroup
   set the defaultStack to pStack
   
   ExportObject the long id of stack pStack,,the password of stack pStack
   
   # if the stack was password protected then none of it's objects are exported
   # but each object still gets sent lcVCSExport and UUIDs are created for each object
   if the password of stack pStack then
      clone stack pStack
      set the name of it to (kPasswordProtectedStackPrefix&pStack)
      put sMainstackPath & slash & UUIDToObjectPath(UUIDForObject(the long ID of stack pStack)) into tObjectPath
      EnsureFolder tObjectPath
      set the fileName of stack (kPasswordProtectedStackPrefix&pStack) to tObjectPath & slash & "stack.binary"
      set the topLeft of stack (kPasswordProtectedStackPrefix&pStack) to 0,0
      save stack (kPasswordProtectedStackPrefix&pStack)
      set the cantDelete of stack (kPasswordProtectedStackPrefix&pStack) to false
      delete stack (kPasswordProtectedStackPrefix&pStack)
   end if
   
end ExportStack

function ExportObjectProperties pObject,pShared,pPassword
   local tImage,tObject,tGroupCardRef,tPaintCompression,tPropertySetA,tUserStateSetA,tUserState,tSharedObject,tCardIDs,tObjectFirstCardRef,tOriginalFolder,tObjectPath,tScript,tID,tCardRef
   put the folder into tOriginalFolder
   unlock messages
   if the environment is "development" then
      dispatch "lcVCSExport" to pObject
   else
      try
         dispatch "lcVCSExport" to pObject
      catch e
         put "lcVCSExport Error "&the internet date&": "&pObject&cr&e into url ("file:"&specialFolderPath("desktop")&"/error.txt")
      end try
   end if
   lock messages
   set the caseSensitive to true
   put UUIDForObject(pObject) into tObject["UUID"]
   
   if not pPassword then
      put sMainstackPath & slash & UUIDToObjectPath(tObject["UUID"]) into tObjectPath
      EnsureFolder tObjectPath
      
      set the folder to tObjectPath
      put pObject into sUUIDMap[tObject["UUID"]]
      
      if word 1 of pObject is "widget" then
         put GetWidgetProperties(pObject) into tObject["properties"]
      else
         -- properties
         put the properties of pObject into tObject["properties"]
         -- delete some props
         repeat for each item tProperty in kPropsToDelete
            delete variable tObject["properties"][tProperty]
         end repeat
         put NativeToUTF8(tObject["properties"]["name"]) into tObject["properties"]["name"]
         -- unicode properties
         repeat for each item tProperty in kUnicodeProps
            if tObject["properties"][tProperty] is not empty then
               put UnicodeToUTF8(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
            end if
         end repeat
      end if
      
      if tObject["properties"]["behavior"] is not empty then
         put UUIDForObject(tObject["properties"]["behavior"]) into tObject["properties"]["behavior"]
      end if
      
      if the cIDEProperties["cCustomControlID"] of pObject <> "" then
         put the cIDEProperties["cCustomControlID"] of pObject into tObject["class"]
      else
         if word 1 of pObject is "bkgnd" then
            put "com.runrev.engine.group" into tObject["class"]
         else
            put "com.runrev.engine."&word 1 of pObject into tObject["class"]
         end if
      end if
      
      # get the script and UTF8 encode it
      put the script of pObject into tScript
      if tScript <> "" then
         put NativeToUTF8(tScript) into tScript
      end if
      
      if word 1 of pObject is not "image" then
         repeat for each item tProperty in kPatternProps
            try
               put the tProperty of pObject into tID
               if tID <> "" and tID <> 0 then
                  -- if unresolved the property will be cleared
                  --_internal resolve image id tID relative to pObject
                  --resolve image id tID relative to pObject
                  #! Workaround using behavior heirarchy until resolve image syntax accepted
                  resolve image id tID relative to pObject
                  put it into tObject["properties"][tProperty]
                  
                  if there is a tObject["properties"][tProperty] then
                     put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                  end if
               end if
            catch e
               write e to STDOUT
            end try
         end repeat
      end if
      switch word 1 of pObject
         case "stack"
            -- should be saved next to the folder
            delete variable tObject["properties"]["fileName"]
            -- only want conflict on width and height difference not stack location
            delete variable tObject["properties"]["rect"]
            put the width of pObject into tObject["properties"]["width"]
            put the height of pObject into tObject["properties"]["height"]
            -- stack id is too likely to cause a conflict and will resolve itself anyway
            delete variable tObject["properties"]["id"]
            break
         case "image"
            if tObject["properties"]["fileName"] is empty and tObject["properties"]["text"] is not empty then
               put the paintCompression of pObject into tObject["properties"]["paintCompression"]
               if tObject["properties"]["paintCompression"] is "rle" then
                  export pObject to file "image.png" as png with standard palette
                  put "png" into tObject["properties"]["paintCompression"]
               else
                  put tObject["properties"]["text"] into url ("binfile:image."&tObject["properties"]["paintCompression"])
               end if
               delete variable tObject["properties"]["fileName"]
            end if
            delete variable tObject["properties"]["text"]
            -- no point having merge conflicts on animated gif frames unless
            -- it's set to a specific frame
            if tObject["properties"]["repeatCount"] is not 0 then
               delete variable tObject["properties"]["currentFrame"]
            end if
            break
         case "group"
         case "bkgnd"
            -- no point exporting group rect if it's not locked
            if not the lockLoc of pObject then
               delete variable tObject["properties"]["rect"]
            end if
            break
         case "button"
            if not the sharedHilite of pObject and pShared then
               put word 3 of pObject into tID
               local tUUID
               repeat for each line tCardID in the cardIDs of the defaultStack
                  if there is a button id tID of card id tCardID of the defaultStack then
                     put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                     put the hilite of button id tID of card id tCardID of the defaultStack into tObject["properties"]["hilite"][tUUID]
                  end if
               end repeat 
            end if 
            if "text" is among the lines of the keys of tObject["properties"] then
               put NativeToUTF8(the text of pObject) into tObject["properties"]["text"]
            end if
            repeat for each item tProperty in kIconProps
               try
                  if tObject["properties"][tProperty] <> "" and tObject["properties"][tProperty] <> 0 then
                     resolve image id tObject["properties"][tProperty] relative to pObject
                     --_internal resolve image id tObject["properties"][tProperty] relative to pObject
                     --resolve image id tObject["properties"][tProperty] relative to pObject
                     put it into tObject["properties"][tProperty]
                     if tObject["properties"][tProperty] is not empty then
                        put UUIDForObject(tObject["properties"][tProperty]) into tObject["properties"][tProperty]
                     else
                        put 0 into tObject["properties"][tProperty]
                     end if
                  end if
               end try
            end repeat
            break
         case "field"
            if not the sharedText of pObject and pShared then
               put word 3 of pObject into tID
               repeat for each line tCardID in the cardIDs of the defaultStack
                  if there is a field id tID of card id tCardID of the defaultStack then
                     put UUIDForObject(the long id of card id tCardID of the defaultStack) into tUUID
                     put the htmlText of field id tID of card id tCardID of the defaultStack into tObject["properties"]["htmlText"][tUUID]
                  end if
               end repeat 
            end if
            break
      end switch
      
      -- reset mac scrollbar width to default
      if tObject["properties"]["scrollbarWidth"] is 16 then
         put 20 into tObject["properties"]["scrollbarWidth"]
      end if
      
      -- custom properties
      if the customKeys of pObject is not empty or the customPropertySets of pObject is not empty then
         repeat for each line tCustomPropertySet in ""&cr&the customPropertySets of pObject
            put the customProperties[tCustomPropertySet] of pObject into tPropertySetA
            if tCustomPropertySet is "uVersion" then
               delete local tPropertySetA["UUID"]
               delete local tPropertySetA["ID"]
               delete local tPropertySetA["REF"]
            end if
            # custom keys can have a plugin for individual keys while for sets it's just for the whole set
            if tCustomPropertySet is "" then 
               put "customKeys" into tCustomPropertySet
               local tCustomProperties
               put the keys of tPropertySetA into tCustomProperties
               repeat for each line tCustomProperty in tCustomProperties
                  repeat for each key tIndex in sPluginsA["keys"][tCustomProperty]
                     if there is a stack sPluginsA["keys"][tCustomProperty][tIndex]["stack"] then
                        local tCustomPropertyValue,tUserStateValue
                        put tPropertySetA[tCustomProperty] into tCustomPropertyValue
                        dispatch "lcVCSFilterExportedProps" to stack sPluginsA["keys"][tCustomProperty][tIndex]["stack"] with pObject,tCustomPropertyValue,tUserStateValue
                        if tCustomPropertyValue is not empty then
                           put tCustomPropertyValue into tPropertySetA[tCustomProperty]
                        else
                           delete variable tPropertySetA[tCustomProperty]
                        end if
                        if tUserStateValue is not empty then
                           put tUserStateValue into tUserStateSetA[tCustomProperty]
                        end if
                        delete variable tUserStateValue
                     end if
                  end repeat
               end repeat
            else
               repeat for each key tIndex in sPluginsA["sets"][tCustomPropertySet]
                  if there is a stack sPluginsA["sets"][tCustomPropertySet][tIndex]["stack"] then
                     dispatch "lcVCSFilterExportedProps" to stack sPluginsA["sets"][tCustomPropertySet][tIndex]["stack"] with pObject,tPropertySetA,tUserStateSetA
                  end if
               end repeat
            end if
            
            if the number of elements in tPropertySetA > 0 then
               put tPropertySetA into tObject["customPropertySets"][NativeToUTF8(tCustomPropertySet)]
            end if
            
            if the number of elements in tUserStateSetA > 0 then
               put tUserStateSetA into tUserState[NativeToUTF8(tCustomPropertySet)]
            end if
            
            delete variable tUserStateSetA
         end repeat
      end if
      if the number of elements of tObject["customPropertySets"] is 0 then
         delete variable tObject["customPropertySets"]
      end if
      local tJSON
      put ArrayToJSON(tObject,,true) into tJSON
      put tJSON into url ("binfile:properties.json")
      if the number of elements of tUserState is not 0 then
         put ArrayToJSON(tUserState,,true) into tJSON
         put tJSON into url ("binfile:userstate.json")
      else
         if there is a file "userstate.json" then
            delete file "userstate.json"
         end if
      end if
      
      repeat for each key tIndex in sPluginsA["script"]
         if there is a stack sPluginsA["script"][tIndex] then
            dispatch "lcVCSFilterExportedScript" to stack sPluginsA["script"][tIndex] with pObject,tScript
         end if
      end repeat
      
      if tScript is not empty then 
         put tScript into url ("binfile:script.utf8")
      else
         if there is a file "script.utf8" then
            delete file "script.utf8"
         end if
      end if
      set the folder to tOriginalFolder
   end if
   
   return tObject["UUID"]
end ExportObjectProperties

command ExportObject pObject,pShared,pPassword
   local tObjects,tOriginalFolder
   put the folder into tOriginalFolder
   -- properties of stack
   
   local tUUID
   put ExportObjectProperties(pObject,pShared,pPassword) into tUUID
   
   -- child objects
   local tIndex="1"
   switch word 1 of pObject
      case "stack"
         -- cards
         local tCards
         repeat for each line tID in the cardIDs of pObject
            put UUIDForObject(the long id of card id tID of pObject)&cr after tCards
            set the currentCard of pObject to the short name of card id tId
            ExportObject the long id of card id tID of pObject,,pPassword
         end repeat
         if not pPassword then
            put tCards into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/cards")
         end if
         -- shared groups
         local tSharedGroups
         if the sharedGroupIDs of pObject is not empty then
            repeat for each line tID in the sharedGroupIDs of pObject
               put UUIDForObject(the long id of background id tID of pObject)&cr after tSharedGroups
               ExportObject the long id of background id tID of pObject,true,pPassword
            end repeat
            if not pPassword then
               put tSharedGroups into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/sharedGroups")
            end if
         end if
         -- substacks
         local tSubstacks
         if the substacks of pObject is not empty then
            repeat for each line tStack in the substacks of pObject
               put UUIDForObject(the long id of stack tStack)&cr after tSubstacks
               ExportStack tStack
            end repeat
            put tSubstacks into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/substacks")
         end if
         break
      case "card"
      case "group"
      case "bkgnd"
         -- only if it's not a cusom control
         if the cIDEProperties["cCustomControlID"] of pObject = "" then
            local tControlRef
            local tLayers
            repeat for each line tControlID in the childControlIDs of pObject
               put the long id of control id tControlID of pObject into tControlRef
               -- layer of shared groups in the list too
               put UUIDForObject(tControlRef)&cr after tLayers
               if not (word 1 of tControlRef is "group" and \
                     the sharedBehavior of tControlRef) then
                  ExportObject tControlRef,pShared,pPassword
               end if
            end repeat
            if tLayers is not empty and not pPassword then
               put tLayers into url ("binfile:"& sMainstackPath & slash & UUIDToObjectPath(tUUID) &"/layers")
            end if
         end if
         break
   end switch
end ExportObject

function q pParam
   return quote&pParam&quote
end q

# Check to see if the parameter is ASCII or not
# returns true if it is not ASCII and therefore needs encoding
function NeedsEncoding pData
   return pData is not empty AND (pData is not an ascii string or pData contains null)
end NeedsEncoding

function ParseConflictedFile tFile
   local tState,tReturn
   -- extract both versions of the file
   -- assumes someone hasn't done something crazy like change the conflicted marker length!!!
   repeat for each line tLine in tFile
      switch char 1 to 7 of tLine
         case "<<<<<<<" -- A starts on next line
            put "A" into tState
            break
         case "|||||||" -- Original starts on next line
            put "O" into tState
            break
         case "=======" -- B starts on next line
            put "B" into tState
            break
         case ">>>>>>>" -- conflict ends
            put "" into tState
            break
         default
            if tState is "" then
               put tLine&cr after tReturn["A"]
               put tLine&cr after tReturn["B"]
            else
               if tState is not "O" then
                  put tLine&cr after tReturn[tState]
               end if
            end if
            break
      end switch
   end repeat
   return tReturn
end ParseConflictedFile

-- this makes sure the datagrid behaviors have the same UUID on everyone's version of the IDE
command SetDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of me into tVersion
   repeat for each key tID in tVersion
      set the customProperties["uVersion"] of control id tID of stack "revDataGridLibrary" to tVersion[tID]
   end repeat
end SetDataGridUUIDs

-- this loads the datagrid's uuids so se don't go searching for them
command LoadDataGridUUIDs
   local tVersion
   put the customProperties["uDataGridBehaviors"] of me into tVersion
   repeat for each key tID in tVersion
      put the long id of control id tID of stack "revDataGridLibrary" into sUUIDMap[tVersion[tID]["UUID"]]
   end repeat
end LoadDataGridUUIDs

-- load plugins
command LoadPlugins pPluginsA
   local tOriginalFolder,tPath
   set the caseSensitive to true
   delete variable sPluginsA -- just incase someone is reloading and has removed a plugin
   put the folder into tOriginalFolder
   
   put revEnvironmentUserPluginsPath()&"/lcVCSPlugins" into tPath
   set the folder to tPath
   
   local tPluginIndexA
   repeat for each line tStack in the files
      -- each plugin is named with the custom property set name
      if there is a stack tStack then
         repeat for each key tIndex in pPluginsA
            if pPluginsA[tIndex] is the short name of stack tStack then 
               # case sensitive is on so use multiple lines to give the possible different case versions
               repeat for each line tCustomPropertySet in the uCustomPropertySet of stack tStack
                  add 1 to tPluginIndexA["sets"][tCustomPropertySet]
                  put the uResolveUUIDs of stack tStack into sPluginsA["sets"][tCustomPropertySet][tPluginIndexA["sets"][tCustomPropertySet]]["resolve UUIDs"]
                  put the short name of stack tStack into sPluginsA["sets"][tCustomPropertySet][tPluginIndexA["sets"][tCustomPropertySet]]["stack"]
               end repeat
               
               repeat for each line tCustomProperty in the uCustomPropertyKey of stack tStack
                  add 1 to tPluginIndexA["keys"][tCustomProperty]
                  put the uResolveUUIDs of stack tStack into sPluginsA["keys"][tCustomProperty][tPluginIndexA["keys"][tCustomProperty]]["resolve UUIDs"]
                  put the short name of stack tStack into sPluginsA["keys"][tCustomProperty][tPluginIndexA["keys"][tCustomProperty]]["stack"]
               end repeat
               
               if the uScript of stack tStack then
                  add 1 to tPluginIndexA["script"]
                  put the short name of stack tStack into sPluginsA["script"]["stack"]
               end if
            end if
         end repeat
      end if
   end repeat
   
   set the folder to tOriginalFolder
end LoadPlugins

command UnloadPlugins
   repeat for each key tCustomPropertySet in sPluginsA["sets"]
      repeat for each key tIndex in sPluginsA["sets"][tCustomPropertySet]
         if there is a stack sPluginsA["sets"][tCustomPropertySet][tIndex]["stack"] and \
               the mode of stack sPluginsA["sets"][tCustomPropertySet][tIndex]["stack"] is 0 then
            delete stack sPluginsA["sets"][tCustomPropertySet][tIndex]["stack"]
         end if
      end repeat
   end repeat
   repeat for each key tCustomProperty in sPluginsA["keys"]
      repeat for each key tIndex in sPluginsA["keys"][tCustomPropertySet]
         if there is a stack sPluginsA["keys"][tCustomProperty][tIndex]["stack"] and \
               the mode of stack sPluginsA["keys"][tCustomProperty][tIndex]["stack"] is 0 then
            delete stack sPluginsA["keys"][tCustomProperty][tIndex]["stack"]
         end if
      end repeat
   end repeat
   repeat for each key tCustomProperty in sPluginsA["scripts"]
      repeat for each key tIndex in sPluginsA["scripts"]
         if there is a stack sPluginsA["scripts"][tIndex]["stack"] and \
               the mode of stack sPluginsA["scripts"][tIndex]["stack"] is 0 then
            delete stack sPluginsA["scripts"][tIndex]["stack"]
         end if
      end repeat
   end repeat
end UnloadPlugins

-- pArray - array to be encoded
-- pForceRootType - can force the root to be an object if it looks like an array
-- pPretty - include whitespace
function ArrayToJSON pArray,pForceRootType,pPretty,pKey
   local tArray,tKeys
   set the caseSensitive to true
   repeat for each line tKey in the keys of pArray
      if pArray[tKey] is an array then
         put "}"&ArrayToJSON(pArray[tKey],pForceRootType,,tKey) into tArray[tKey]
      else if IsString(pArray[tKey]) then
         put "}}"&NativeToUTF8(pArray[tKey]) into tArray[tKey]
      else if needsEncoding(pArray[tKey]) then
         put "base64Decode("&base64Encode(pArray[tKey])&")" into tArray[tKey]
      else 
         -- force all elements to be strings
         put "}}"&pArray[tKey] into tArray[tKey]
      end if
   end repeat
   return mergJSONEncode("tArray",pForceRootType,pPretty)
end ArrayToJSON

function JSONToArray pJSON
   local tArray,tKeys
   if pJSON = "" then return ""
   set the caseSensitive to true
   put mergJSONDecode(pJSON,"tArray") into tKeys
   repeat for each line tKey in the keys of tArray
      if tKey is among the lines of tKeys then
         put JSONToArray(tArray[tKey]) into tArray[tKey]
      else
         if char 1 to 13 of tArray[tKey] is "base64Decode(" then
            put base64Decode(char 14 to -2 of tArray[tKey]) into tArray[tKey]
         end if
      end if
   end repeat
   return tArray
end JSONToArray

function FindParent pObject,pType,pShared
   local tStat = "true",tType
   
   put word 1 of pObject into tType
   if tType is "bkgnd" then
      put "group" into tType
   end if
   
   if pShared then
      if tType is "group" then
         put the sharedBehavior of pObject into tStat
      else if word 1 of pObject is "card" then
         return empty
      end if
   end if
   
   if tType is pType and tStat then
      return pObject
   else
      return FindParent(the long owner of pObject,pType,pShared)
   end if
end FindParent



// Return a path relative to the stack directory for an object
// Note stacks are treated differently and their data is in the stack directory
// c0/63d56b-c5b3-429e-af00-5a6f97d7464d
private function UUIDToObjectPath pUUID
   return char 1 to 2 of pUUID & slash & char 3 to -1 of pUUID
end UUIDToObjectPath

// Return a uuid for an object given the path relative to the stack directory
// Note stacks are treated differently and their data is in the stack directory
private function ObjectPathToUUID pObjectPath
   set the itemDelimiter to slash
   return item 1 of pObjectPath & item 2 of pObjectPath
end ObjectPathToUUID

# Cleans conflict markers
#! Warning - only use on layer files
#! TODO Improve with regex that handles all conflict markers
private function CleanLayerFile pData
   if "<<<<<<<" is in pData then
      filter pData without "<<<<<<<*"
      filter pData without "|||||||*"
      filter pData without "=======*"
      filter pData without ">>>>>>>*"
   end if
   return pData
end CleanLayerFile

command DeployRelease
   local tProjectA
   
   put ProjectForStackFile(the effective filename of me,true) into tProjectA
   
   local tOriginalFolder
   put the folder into tOriginalFolder
   
   if tProjectA is an array then
      set the folder to tProjectA["exported stackFiles"][1]
      
      local tDescribe
      put line 1 of shell("git describe") into tDescribe
      
      set the uVersion["REF"] of me to tDescribe
      
      local tRepoRoot
      put line 1 of shell("git rev-parse --show-toplevel") into tRepoRoot
      
      set the directory to tRepoRoot
      if there is not a folder "build" then
         create folder "build"
      end if
      
      local tStackFile
      put the filename of me into tStackFile
      put tStackFile into tlcVCSPath
      
      set the filename of me to (the folder&"/build/lcVCS.livecode")
      save me
      
      set the itemDel to slash
      put "lcVCSPlugins" into item -1 of tlcVCSPath
      revDeleteFolder tRepoRoot&"/build/lcVCSPlugins"
      revCopyFolder tlcVCSPath,tRepoRoot&"/build"
      
      delete file (tRepoRoot&"/build/README.md")
      revCopyFile tRepoRoot&"/README.md",tRepoRoot&"/build"
      
      delete file (tRepoRoot&"/build/LICENSE.txt")
      revCopyFile tRepoRoot&"/LICENSE.txt",tRepoRoot&"/build"
      
      set the filename of me to tStackFile
      
      set the folder to "build"
      get shell("zip -r "&quote&tRepoRoot&"/lcVCS-"&tDescribe&".zip"&quote&" .")
   end if
   
   set the folder to tOriginalFolder
end DeployRelease
