script "lib_Menu"
--> MetaData
-
license: GPLv3
name: lib_Menu
type: script library
copyright: David Bovill
licence:  GPLv3
version: 0.3

/*
Latest library to implement dynamic menus from script introspection.

It is designed to be just the minimal set of handlers needed to implement the handlers
-  menu_PullDown
-  menu_PopUp

The actual menu_Button contains a simple script:

on menuPick menuPath
   menu_SendMessage menuPath
end menuPick

which dispatches the appropriate command to the controller that handles the menu action.
There is an optional "lib_MenuEdit" library which adds the ability to option navigate to a menus script.

The library "lib_MenuAuthoring" is required for creating the menu_Table using menu_Update.
However it is not needed if yo are loading the menuTable from stored arrays that have been authored in advance.
*/


--> Objects
-
getprop menu_Button
   -- needs to be in an open stack
   put the long id of btn 1 of cd 1 of stack "View|Index|Simple" into mButton
   return mButton
   
   -- put lcw_HomeStackName() into menuButtonStackName
   put "LCW" into menuButtonStackName
   -- put "lcw_Menus" into menuButtonStackName
   
   if exists (button "Global Menu Button" of cd 1 of stack menuButtonStackName) is false then pass menu_Button
   return the long id of button "Global Menu Button" of cd 1 of stack menuButtonStackName
end menu_Button

command lcw_CreateMenuButton pProjectName
   -- this should be part of the new script-only  menu library 
   -- in case we call this handler more that once, do not create multiple buttons
   if pProjectName is empty then
      -- put lcw_HomeStackName() into pProjectName
      put "lcw_Menus" into pProjectName
   end if
   
   if exists (button "Global Menu Button" of cd 1 of stack pProjectName) then
      return the long id of button "Global Menu Button" of cd 1 of stack pProjectName
   end if
   
   -- this should be a "menu" button
   go to cd 1 of stack pProjectName
   create invisible button "Global Menu Button"
   put it into mButton
   
   menu_SetButtonStyle mButton
   
   put "on menuPick menuPath" into someScript
   put CR & "   menu_SendMessage menuPath" after someScript
   put CR & "end menuPick" after someScript
   
   set the script of mButton to someScript
   return mButton
end lcw_CreateMenuButton
   
command menu_SetButtonStyle pButton
   if pButton is empty then put the menu_Button of me into pButton
   set the style of pButton to "menu"
   -- set the menumode of pButton to "popup"
   set the menumode of pButton to "pulldown"
   -- set the backgroundcolor of pButton to "green" -- for no reason
end menu_SetButtonStyle


--> Menu | Basics
-
command menu_SendMessage mPath, pMenuTarget, pCreateActiveArray
   menu_DeconstructPath mPath, foundPath, subMenuPath, pigeon, mController, mTitlePath, mItemType -- look up in array
   if the result is false then return empty
   if exists (mController) is false then breakPoint
   
   if exists (pMenuTarget) then
      menu_SetItemTargetOveride mPath, pMenuTarget -- not sure we are using this any more ?
      put pMenuTarget into mTarget
   else
      put menu_TargetFromGlobal (mPath) into mTarget
   end if
   
   menu_SetSentPath mPath -- everything can be derived from that
   menu_SetTitlePath mTitlePath     
   
   if the menu_OptionEdit of the target is true then
      -- dispatching in case "lib_MenuEdit" is not present"
      dispatch "menu_EditMenuItem" with pigeon,mController,mTarget
   else
      put token 1 of pigeon into mCommand
      put token 2 of pigeon into firstParamName
      put token 4 of pigeon into secondParamName
      dispatch mCommand to mController with mTarget, subMenuPath
   end if
   send "menu_DeleteActiveArray" to mController in 2 ticks
end menu_SendMessage

getprop menu_OptionEdit
   put the optionkey is "Down" into someBoolean
   
   -- alternative to dispatch as a way of disabling option-editing of menus if library is not present
   -- put someBoolean and "lib_MenuEdit" is among the lines of the stacksinuse int someBoolean 
   
   -- put the uOPN ["menu_OptionEdit"] of me is not false into someBoolean
   return someBoolean
end menu_OptionEdit

command menu_PopUp pMenuTitle, pLocation, pTargetObject
   if pTargetObject is empty then put the long id of the target into pTargetObject
   if pMenuTitle is empty then put the menu_Title of pTargetObject into pMenuTitle
   if pMenuTitle is empty then put "Menu" into pMenuTitle
   
   set the menu_TextFromTitle of pTargetObject to pMenuTitle
   put the result into mText
   if mText is empty then return "false"
   
   put the menu_Button of pTargetObject into mButton
   if pLocation is not a point then
      popup mButton
   else
      popup mButton at pLocation
   end if
   return true
end menu_PopUp

command menu_PullDown pMenuTitle, pLocation, pTargetObject
   if pTargetObject is empty then put the long id of the target into pTargetObject
   -- if pMenuTitle is empty then put the menu_ToolOrTitle of pTargetObject into pMenuTitle
   if pMenuTitle is empty then put the menu_Title of pTargetObject into pMenuTitle
   if pMenuTitle is empty then put "Menu" into pMenuTitle
   
   set the menu_TextFromTitle of pTargetObject to pMenuTitle
   put the result into mText
   if mText is empty then
      -- lcw_Notify pMenuTitle -- often useful, but also annoying :)
      return "false"
   end if
   
   put the menu_Button of pTargetObject into mButton
   if exists (mButton) is false then return false
   
   if pLocation is not a point then
      put the bottomleft of pTargetObject into pLocation
      add 3 to item 2 of pLocation
   end if
   if exists (mButton) is false then return false
   popup mButton at pLocation
   return true
end menu_PullDown

command menu_MouseDown pMenuTitleTable, pTargetObject
   if exists(pTargetObject) is false then put the long id of the target into pTargetObject
   if pMenuTitleTable is empty then put the menu_Title of pTargetObject into pMenuTitleTable
   if pMenuTitleTable is empty then put "Menu" into pMenuTitleTable
   set the menu_TextFromTitle of pTargetObject to pMenuTitleTable
   put the result into mText
   if mText is empty then return "false"
   return mText
end menu_MouseDown


--> Deps
-
getprop menu_CheckTarget [topMenuTarget]
   /*
   This is a default sent by  "menu_ConvertTable" 
   Usually - all you want to do is check that the topMenuTarget exists.
   But it could be a file or some other non-Rev structure.
   */
   return true
end menu_CheckTarget

getprop menu_Controller [pMenuTitle]
   put the long id of the target into targetObject
   
   -- put the burnt_MenuController [pMenuTitle] of targetObject into mController
   -- if exists(mController) then return mController
   
   -- put menu_GetDefaultController (pMenuTitle, targetObject, false) into mController
   -- check if it is a global menu
   -- if menu_TitleIsGlobal (mTitle) then
   put menu_GetGlobalController (pMenuTitle) into mController
   if exists (mController) is true then
      return mController
   end if
   -- end if
   
   return targetObject
end menu_Controller

getprop menu_DataArray
   -- the problem with this is if the target has been cloned or copied
   -- the menu_Controller will have changed
   put the customproperties ["menu_Table"] of the target into mTitleTableArray
   return mTitleTableArray
end menu_DataArray

getprop menu_Table [pMenuTitle]
   if pMenuTitle is empty then put the menu_Title of the target into pMenuTitle
   if pMenuTitle is empty then return empty
   
   if word 1 of pMenuTitle = "Global" and word 2 of pMenuTitle = "|" then
      put menu_GetGlobalTable (pMenuTitle) into mTable
      return mTable
   else
      put the menu_Controller [pMenuTitle] of the target into mController
      put the menu_DataArray of mController into menuTableArray
      put menuTableArray [pMenuTitle] into mTable
      
      -- hack
      -- fix local contrllers in cases where the object has been copied to another stack
      set the itemdelimiter to tab
      repeat for each line mTableLine in mTable
         put mController into item 3 of mTableLine
         put mTableLine & CR after fixedLocalMenuTable
      end repeat
      delete char -1 of fixedLocalMenuTable
      return fixedLocalMenuTable
   end if
end menu_Table

setprop menu_Text menuText
   /*
   menu_Text is a property of the targetObject.
   the text is derived from the menu_Table
   which is in turn stored with the menu_Controller 
   
   menu_Text is now quickly constructed from the menu_Table (cached with the menu_Controller)
   Submenus are created by recursively calling menu_Text on the submenu menu_Title
   So script should be modified to prevent recursion.
   
   While fetching the text (usually on a mousedown)
   the menu_Table is also converted to an array
   and added to the global gTemp_ActiveMenuArray
   */
   put the long id of the target into targetObject
   put the menu_Button of targetObject into mButton
   if mButton is empty then return empty
   -- if the object_IsMenuButton of mButton is false then return  empty
   
   set the text of mButton to menuText
   return mButton
end menu_Text

setprop menu_TextFromTitle [pMenuTarget] mTitleTable
   -- don't like the syntax of this
   put the long id of the target into tObject
   
   set the itemdelimiter to tab
   put item 1 of line 1 of mTitleTable into mTopTitle
   
   if mTopTitle is empty then
      if the controlkey is "Down" then
         -- put the menu_ToolTitle of tObject into mTopTitle
         put the menu_Title of tObject into mTopTitle
      else
         put the menu_Title of tObject into mTopTitle
      end if
   end if
   put the menu_Controller [mTopTitle] of tObject into mTopController
   
   menu_DeleteActiveArray
   menu_SetTargetObject tObject
   menu_SetTopController mTopController
   
   put menu_GetTextFromTitleTable (mTitleTable, tObject, pMenuTarget) into mText
   menu_SetActiveText mText 
   if mText is not empty then set the menu_Text of tObject to mText
   return mText
end menu_TextFromTitle

command menu_AddBooleanLine @mText, mLine, paramProp, topMenuTarget, mController
   -- ignoreCall: paramProperty,g
   
   put mLine & CR after mText
   if the number of tokens of paramProp = 1 then
      put paramProp & "[" & topMenuTarget & "]" into paramProperty
   else
      put paramProp into paramProperty
   end if
   try
      put the paramProperty of mController into someBoolean
      
      if someBoolean is true then
         put "!ctrue" & CR & "!nfalse" into subMenu
      else if someBoolean is false then
         put "!ntrue" & CR & "!cfalse" into subMenu
      else
         put "true" & CR & "false" into subMenu
      end if
      put text_Indent (subMenu) into subMenu
      put subMenu & CR after mText
      return empty
   catch tError
      put merge("Error: fetching boolean custom property '[[paramProperty]]' of mController") & CR into someError
      put CR after someError
      put "mController:" && mController after someError
      
      -- lcw_Notify someError, true
      put someError -- so we can dig into what went wrong
      -- error_LogBoolean mController, mTableLine, mTitle, mTitlePath, mLine, tError
      
      return someError
   end try
end menu_AddBooleanLine

function menu_CheckDisabled mFormatProp, mTarget, mController
   -- ignoreCall: mFormatProperty,g
   
   if mFormatProp is empty then return false
   try
      put mFormatProp & "[" & mTarget & "]" into mFormatProperty
      put the mFormatProperty of mController into itemIsDisabled
      return itemIsDisabled
   catch someError
      return someError
   end try
end menu_CheckDisabled

function menu_CheckDisabledItem mFormatProp, mTarget, mController, menuIsDisabled
   -- ignoreCall: mFormatProperty,g
   
   if menuIsDisabled is true then return true
   if mFormatProp is empty then return false
   try
      put mFormatProp & "[" & mTarget & "]" into mFormatProperty
      put the mFormatProperty of mController into itemIsDisabled
   catch someError
      -- error_CheckDisabled mController, mTarget, mTitlePath, mTableLine, someError
   end try
   return itemIsDisabled
end menu_CheckDisabledItem

command menu_CheckRecursionOnExtract mTitle, mController
   -- used by "menu_ExtractTableFromScript"
   global gLCW
   
   put menu_TitleIsGlobal (mTitle) into menuIsGlobal
   if menuIsGlobal is true then
      put gLCW ["activeMenuArray"]["Recursion title Check"][mTitle] is not empty into isRepeated
   else
      put gLCW ["activeMenuArray"]["Recursion title Check"][mController][mTitle] is not empty into isRepeated
   end if
   
   -- put gLCW ["activeMenuArray"]["Recursion title Check"] into titlesSoFar
   -- if mTitle is among the lines of titlesSoFar then
   
   if isRepeated is true then 
      breakpoint
      
      /*
      put merge ("[[menu_CheckRecursionOnExtract]]: Recursion: '[[mTitle]]'. Check for duplicate menus in script.") into errorMessage 
      put errorMessage
      display_ActiveMenuArray mTitle
      edit the script of mController
      */
      
      return true
   end if
   
   -- this is not checking for recursion (we check for a repeat - which is stronger but has false positives)
   if menuIsGlobal is true then
      put "menu_CheckRecursionOnExtract" into gLCW ["activeMenuArray"]["Recursion title Check"][mTitle]
   else
      put "menu_CheckRecursionOnExtract" into gLCW ["activeMenuArray"]["Recursion title Check"][mController][mTitle]
   end if
   
   /*
   -- should speed up using an array
   line_Insert mTitle, titlesSoFar
   put titlesSoFar into gLCW ["activeMenuArray"]["Recursion title Check"]
   */
   return false
end menu_CheckRecursionOnExtract

command menu_CheckSub @subMenu, paramProp, mController, mTarget, mItemType
   -- ignoreCall: paramProperty,g
   
   if paramProp is empty then return empty
   -- passing parameter can cause a custom property to fail to return when no getprop is there.
   put paramProp & "[" & mTarget & "]" into paramProperty
   try
      put the paramProperty of mController into checkedItems
      if checkedItems is empty and mItemType is among the items of "custom,fixed" then
         -- a hack ???
         -- put the paramProp of mController into checkedItems
      end if
      
      replace comma with CR in checkedItems
      repeat for each line checkedItem in checkedItems
         menu_SetCheckedItem checkedItem, subMenu, true
      end repeat
   catch tError
      put paramProperty & CR & mController into errorInfo
      if exists (mController) then edit the script of mController
   end try
end menu_CheckSub

command menu_CleanCheckMarks @mText
   replace "!c" with empty in mText
   replace "!n" with empty in mText
end menu_CleanCheckMarks

function menu_CleanLine mLine  
   if char 1 to 2 of mLine is among the items of "!c,!n" then delete char 1 to 2 of mLine
   if char 1 of mLine = "(" then delete char 1 of mLine
   -- replace "(" with empty in someMenu	# only at start!
   -- put replacetext (mLine, "/.*", empty) into mLine
   
   -- accelerator keys
   set the itemdelimiter to "/"
   put item 1 of mLine into mSendLine
   
   if mLine is not mSendLine then breakpoint
   return mSendLine
end menu_CleanLine

function menu_CleanMarks mText  
   menu_CleanCheckMarks mText
   -- replace "(" with empty in mText	# only at start!
   put replacetext (mText, "(?m)^\(", empty) into mText
   put replacetext (mText, "/.*", empty) into mText
   return mText
end menu_CleanMarks

function menu_ConvertTable mTable, mView, pTitlePath, pTextPath, pMenuTarget, pMenuIsDisabled
   -- ignoreCall:  dynamicSubmenuTitleProp,g
   -- ignoreCall:  •••,c
   -- this is called first for each line of mTable to draw a menu
   -- the only handler to use "menu_GetDefaultController" aside from the "menu_Controller"
   
   global gLCW
   local mPath, mTitlePath, mController, pigeon, mTitle, mLine, mFormatProp, mItemType, submenuProp, paramProp   
   
   repeat for each line mTableLine in mTable
      if mTableLine is "-" then
         put "-" & CR after mText
         next repeat
      end if
      menu_DeconstructTableLine mTableLine, mController, pigeon, mTitle, mLine, mFormatProp, mItemType, submenuProp, paramProp, mSendLine
      
      switch
         case mItemType is among the items of "submenu"
            put submenuProp into subMenuTitle
            
            if pTextPath is empty then
               put mSendLine into mPath
            else
               put pTextPath & "|" & mSendLine into mPath
            end if
            
            if pTitlePath is empty then
               put mTitle & "/" & subMenuTitle into mTitlePath -- first time
               -- should I put something into pTitlePath?
            else
               -- already added subMenuTitle first time above
               put pTitlePath & "/" & mTitle & "/" & subMenuTitle into mTitlePath
               -- breakPoint
            end if
            break
         case mItemType = "insert"
            put pTextPath into mPath
            
            if pTitlePath is empty then
               put mTitle into mTitlePath
            else
               put pTitlePath & "/" & mTitle into mTitlePath     
               -- put pTitlePath into mTitlePath
            end if
            break
         default
            if pTextPath is empty then
               put mSendLine into mPath
            else
               put pTextPath & "|" & mSendLine into mPath
            end if
            
            if pTitlePath is empty then
               put mTitle into mTitlePath
            else
               put pTitlePath & "/" & mTitle into mTitlePath
            end if
      end switch
      if mTitlePath begins with "/" then breakPoint
      _addToMenuActiveArray mPath, mTitlePath, pigeon, mController, mView, mItemType, pMenuTarget
      if exists (mController) is false then next repeat
      
      try
         -- first lets allow the mController to initialise itself and avoid repeat calls to common routines
         if initArray [mController]["menu_Init"] is not true then
            -- now it gets sent one time only for each mController, or recursive call to a submenu
            -- could cut out multiple call on recursion with some hacking with locals or globals.
            dispatch "menu_Init" to mController with mView,mPath,mTitlePath -- think mView is the same as targetObject
            put true into initArray [mController]["menu_Init"]
         end if
         
         -- get the mTarget next
         if pMenuTarget is empty then
            put menu_TargetFromGlobal (mPath) into mTarget -- mTarget must be same as what "menu_SendMessage 
         else
            put pMenuTarget into mTarget
         end if
         
         -- now check the mTarget
         -- if pMenuIsDisabled is empty then
         -- first time (not used for recursive sub menus - these are already checked in the recursive handler)
         -- we get an error if mTarget is custom set to an array.
         try
            put initArray [mController]["menu_CheckTarget"][mTarget]["already checked"] is true into menuAlreadyChecked
            if menuAlreadyChecked is true then
               put initArray [mController]["menu_CheckTarget"][mTarget]["targetOK"] into targetOK
            else
               put the menu_CheckTarget [mTarget] of mController into targetOK
               put targetOK into initArray [mController]["menu_CheckTarget"][mTarget]["targetOK"]
               put true into initArray [mController]["menu_CheckTarget"][mTarget]["already checked"]
            end if
         catch e
            put false into targetOK
            
            breakPoint
            put the menu_CheckTarget [mTarget] of mController into targetOK
         end try
         
         switch targetOK
            case "delete"
               next repeat
               break
            case false
               put targetOK is false into menuIsDisabled
               break
            case true
               put targetOK is false into menuIsDisabled
               break
            default
               -- could be used to replace a disabled menu with another menu
               -- use to fix reason why menu is disabled for instance
               put targetOK is false into menuIsDisabled
         end switch
         -- else
         -- allows override (but should false = empty = do another check for recursive menus?)
         -- put pMenuIsDisabled into menuIsDisabled
         -- end if
         
         switch mItemType
            -- case mItemType = "inserted"
            case "insert"
               -- not sure "insert" is working fully (with disabling etc 
               -- needs testing !!!
               -- seems not to check the menu_CheckTarget?
               put pigeon into dynamicSubmenuTitleProp
               
               if subMenuProp is empty then
                  -- old version of mTable
                  put subMenuTitle into insertedMenuTitle
                  put the menu_Controller [insertedMenuTitle] of mController into insertedMenuController
                  -- put menu_GetDefaultController (insertedMenuTitle, mController, false) into insertedMenuController
               else if dynamicSubmenuTitleProp is empty then
                  put subMenuProp into insertedMenuTitle
                  put paramProp into insertedMenuController
               else
                  -- experimental and not tested
                  breakPoint
                  put the dynamicSubmenuTitleProp of mController into insertedMenuTitle
                  put the menu_Controller [insertedMenuTitle] of mController into insertedMenuController
                  -- put menu_GetDefaultController (subMenuTitle, mController, false) into insertedMenuController
               end if
               
               menu_IncludeMenuText mText, insertedMenuTitle, mView, insertedMenuController, menuIsDisabled, mTitlePath, mPath, pMenuTarget
               break
            case "submenu"
               put pigeon into dynamicSubmenuTitleProp
               
               -- if the number of tokens of pigeon < 2 then -- pigeon is empty then
               if true then -- temp hack for now !!!
                  put subMenuProp into subMenuTitle
                  put paramProp into subMenuController
                  if subMenuController is empty then
                     -- a temporary hack for old menu tables
                     -- put menu_GetDefaultController (subMenuTitle, mController, false) into subMenuController
                     put the menu_Controller [subMenuTitle] of mController into subMenuController
                  end if
               else
                  -- experimental and not tested 
                  -- idea is to allow a getprop to dynamicaly return a subMenuTitle based on local conditions
                  breakPoint
                  put the dynamicSubmenuTitleProp of mController into subMenuTitle
                  -- put menu_GetDefaultController (subMenuTitle, mController, false) into subMenuController
                  put the menu_Controller [subMenuTitle] of mController into subMenuController
               end if
               if exists (subMenuController) is false then
                  -- menu needs fixing
                  -- breakPoint
                  next repeat
               end if
               put mPath into subMenuPath
               put mTitlePath into subMenuTitlePath
               put mTarget into subMenuTarget
               
               try
                  if initArray [subMenuController][subMenuTarget]["already checked"] is not true then
                     put the menu_CheckTarget [subMenuTarget] of subMenuController into targetOK
                     put targetOK into initArray [subMenuController][subMenuTarget]["targetOK"]
                     put true into initArray [subMenuController][subMenuTarget]["already checked"]
                  else
                     put initArray [subMenuController][subMenuTarget]["targetOK"] into targetOK
                  end if
               catch e
                  put false into targetOK
               end try
               
               switch targetOK
                  case "delete"
                     next repeat
                     break
                  case false
                     put true into subMenuIsDisabled
                     break
                  case true
                     put menu_CheckDisabled (mFormatProp, mTarget, mController) into subMenuIsDisabled
                     break
                  default
                     -- could be used to replace a disabled menu with another menu
                     -- use to fix reason why menu is disabled for instance
                     put menu_CheckDisabled (mFormatProp, mTarget, mController) into subMenuIsDisabled
               end switch
               
               switch subMenuIsDisabled
                  case "delete"
                     break
                  case true
                     menu_DisableLine mLine
                     menu_InsertSubMenu mText, mLine, subMenuTitle, mView, subMenuController, mTitlePath, mPath, pMenuTarget, subMenuIsDisabled
                     break
                  default
                     menu_InsertSubMenu mText, mLine, subMenuTitle, mView, subMenuController, mTitlePath, mPath, pMenuTarget, subMenuIsDisabled
               end switch
               
               /*
               if subMenuIsDisabled is true then
                  menu_DisableLine mLine
               else if subMenuIsDisabled is not false then
                  -- error_CheckDisabled mController, mTarget, mTitlePath, mTableLine, someError
               end if
               menu_InsertSubMenu mText, mLine, subMenuTitle, mView, subMenuController, mTitlePath, mPath, pMenuTarget, subMenuIsDisabled
               */
               
               break
            default
               -- it is not a recursively called menu insertion
               -- lets check if menu item is disabled
               if menuIsDisabled is true then
                  put true into itemIsDisabled
               else
                  put menu_CheckDisabledItem (mFormatProp, mTarget, mController, false, mTitlePath, mTableLine) into itemIsDisabled
               end if
               
               switch
                  case itemIsDisabled = "delete"
                     -- dont add mLine
                     break
                  case itemIsDisabled =  true or menuIsDisabled is true
                     -- disable mLine
                     menu_DisableLine mLine
                     put mLine & CR after mText
                     break
                  case itemIsDisabled is not false and itemIsDisabled is not empty
                     -- replace mLine with substituted text
                     put itemIsDisabled & CR after mText
                     break
                  case mItemType = "boolean"
                     -- add check sub menu to mLine
                     menu_AddBooleanLine mText, mLine, paramProp, mTarget, mController
                     break
                  case mItemType = "fixed"
                     -- fetch sub menu from custom property and add to mLine
                     menu_InsertFixed mText, mLine, pigeon, mController, paramProp, mTarget, mItemType
                     break
                  case mItemType is among the items of "custom submenu,custom external"
                     -- fetch sub menu from getprop and add to mLine
                     menu_FetchCustomMenuItems mText, mLine, submenuProp, mController, paramProp, mTarget, mItemType
                     break
                  default -- mItemType = empty
                     -- a plain menu item - just add to mLine
                     put mLine & CR after mText
               end switch
         end switch
      catch someError
         -- display_Text (mTableLine & CR & CR & someError), mTableLine
      end try
   end repeat
   menu_TidyText mText
   return mText
end menu_ConvertTable

command menu_DeconstructPath mPath, @foundPath, @foundParam, @pigeon, @mController, @mTitlePath, @mItemType
   -- lets search to see if there is a param being sent with the menu
   -- pity menus don't use a different delimiter like tab
   -- as the text of the menu item could include "|" we can't just check the first item
   -- but should search back down through all items
   
   global gLCW
   
   put empty into foundParam
   put empty into pigeon
   put empty into mController
   put empty into mTitlePath
   put empty into mItemType
   
   set the itemdelimiter to "|"
   put the number of items of mPath into maxNum
   repeat with itemNum = maxNum down to 1
      put item 1 to itemNum of mPath into foundPath
      put gLCW ["activeMenuArray"]["mPath"][foundPath] into foundArray
      
      if foundArray is an array then
         -- found a mPath in active menu global
         
         put foundArray ["pigeon"] into pigeon
         put foundArray ["mController"] into mController
         put foundArray ["mItemType"] into mItemType
         put foundArray ["mTitlePath"] into mTitlePath
         
         put item (itemNum + 1) to maxNum of mPath into foundParam
         return true
      end if
   end repeat
   
   put empty into foundPath
   return false
end menu_DeconstructPath

command menu_DeconstructTableLine mTableLine, @mController, @pigeon, @mTitle, @mLine, @mFormatProp, @mItemType, @submenuProp, @paramProp, @mSendLine
   set the itemdelimiter to tab
   
   put item 1 of mTableLine into mLine
   put item 2 of mTableLine into pigeon
   put item 3 of mTableLine into mController
   put item 4 of mTableLine into mTitle
   put item 5 of mTableLine into mFormatProp
   put item 6 of mTableLine into mItemType
   put item 7 of mTableLine into submenuProp
   put item 8 of mTableLine into paramProp
   
   put item 9 of mTableLine into mSendLine
   if mSendLine is empty then
      put menu_CleanLine (mLine) into mSendLine -- for now while the mTables have not all been updated
      
      -- could update menu table here
   end if
end menu_DeconstructTableLine

command menu_DeleteActiveArray
   global gLCW
   delete variable gLCW ["activeMenuArray"]
end menu_DeleteActiveArray

command menu_DisableLine @mLine
   if char 1 of word 1 of mLine is not "(" then put "(" before word 1 of mLine
end menu_DisableLine

command menu_FetchCustomMenuItems @mText, mLine, submenuProp, mController, paramProp, mTarget, mItemType
   -- ignoreCall:  submenuProperty,g
   try
      put mLine & CR after mText
      
      put submenuProp & "[" & mTarget & "]" into submenuProperty
      put the submenuProperty of mController into subMenu
      
      if subMenu is not empty then
         -- check submenu
         replace comma with CR in subMenu
         menu_CheckSub subMenu, paramProp, mController, mTarget, mItemType
         put text_Indent (subMenu) into subMenu
         put subMenu & CR after mText
      end if
   catch someError
      -- error_LogCustomMenuItems mController, submenuProperty, someError
   end try
end menu_FetchCustomMenuItems

command  menu_FixGlobalTitleArray @gMenuTable, gMenuTitle
   if gMenuTable is empty then
      put the menu_Controller [gMenuTitle] of the target into mController
      put the menu_DataArray of mController into gMenuTitleArray
      put gMenuTitleArray [gMenuTitle] into gMenuTable
      
      -- now set it
      menu_SetGlobalTable gMenuTitle, gMenuTable
   end if
end menu_FixGlobalTitleArray

function menu_GetGlobalArray
   global gLCW
   put gLCW ["Global Menus"] into menuGlobalArray
   return menuGlobalArray
end menu_GetGlobalArray

function menu_GetGlobalController gMenuTitle
   -- was "menu_GlobalController"
   put menu_GetGlobalArray() into gMenuArray
   put gMenuArray [gMenuTitle]["mController"] into mController
   return mController
end menu_GetGlobalController

function menu_GetGlobalTable gMenuTitle
   put menu_GetGlobalTitleArray (gMenuTitle) into gMenuTitleArray
   put gMenuTitleArray ["gMenuTable"] into gMenuTable
   
   menu_FixGlobalTitleArray gMenuTable, gMenuTitle
   return gMenuTable
end menu_GetGlobalTable

function menu_GetGlobalTitleArray gMenuTitle
   put menu_GetGlobalArray() into menuGlobalArray
   put menuGlobalArray [gMenuTitle] into gMenuTitleArray
   return gMenuTitleArray
end menu_GetGlobalTitleArray

function menu_GetLineNum someMenuItem, someMenu
   set the itemdelimiter to tab
   repeat with lineNum = 1 to the number of lines of someMenu
      put item -1 of line lineNum of someMenu into lastItem
      
      if char 1 of lastItem = "!" then delete char 1 to 2 of lastItem
      if char 1 of lastItem = "(" then delete char 1 of lastItem
      if lastItem = someMenuItem then
         return lineNum
      end if
   end repeat
   return 0
   
   replace "/" with "\/" in someMenuItem
   put menu_CleanMarks (someMenu) into testMenu
   
   -- does not return the title with the greatest indent
   -- and so does not deal with titles which include subtitles of the same name ie colour names
   -- return outline_LineOffset(someMenuItem, testMenu)
   
   -- needs to be fast (repeats are)
   set the itemdelimiter to tab
   repeat with lineNum = the number of lines of someMenu down to 1
      get item -1 of line lineNum of someMenu
      if it = someMenuItem then
         return lineNum
      end if
   end repeat
   return 0
end menu_GetLineNum

function menu_GetTable mTitle, mController
   if word 1 of mTitle = "Global" and word 2 of mTitle = "|" then
      put menu_GetGlobalTable (mTitle) into mTable
      menu_FixGlobalTitleArray mTable, mTitle
   else
      put the menu_DataArray of mController into menuTableArray
      put menuTableArray [mTitle] into mTable
   end if
   return mTable
end menu_GetTable

function menu_GetTargetObject
   global gLCW
   put gLCW ["activeMenuArray"]["top"]["targetObject"] into targetObject
   return targetObject
end menu_GetTargetObject

function menu_GetTextFromTitleTable mTitleTable, targetObject, pMenuTarget
   -- repeats over mTitles in table
   -- called by "menu_PullDown" etc to dynamically create and "set the menu_Text of pTargetObject"
   local mText, pTitlePath, mTopTitle
   global gLCW
   
   replace comma with tab in mTitleTable
   set the itemdelimiter to tab
   repeat for each line mTitleLine in mTitleTable
      put item 1 of mTitleLine into mTitle
      put item 2 of mTitleLine into mType
      put item 3 of mTitleLine into pTextPath
      
      if mTitleLine = "-" then
         put "-" & CR after mText
         next repeat
      end if
      
      -- menu_CheckRecursionOnGet mTitle, targetObject
      menu_CheckRecursionOnExtract mTitle, targetObject
      if the result is true then
         breakpoint
         next repeat
      end if
      
      put the menu_Table [mTitle] of targetObject into mTable
      
      switch 
         case mType = "submenu"  
            if pTextPath is empty then put menu_MenuTextFromTitle (mTitle) into pTextPath -- old ?? Why not use "put mType into pTitlePath"
            
            put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into moreMenuText
            if moreMenuText is empty then
               -- submenu is empty
            else
               put pTextPath  & CR after mText
               put text_Indent (moreMenuText) & CR after mText
            end if
            break
         case mType is not empty
            put mType into pTitlePath
            put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into moreMenuText
            if moreMenuText is not empty then
               put moreMenuText & CR after mText
            end if
            break
         default
            put menu_ConvertTable (mTable, targetObject, pTitlePath, pTextPath, pMenuTarget) into moreMenuText
            if moreMenuText is not empty then
               put moreMenuText & CR after mText
            end if
      end switch
   end repeat
   delete char -1 of mText
   return mText
end menu_GetTextFromTitleTable

function menu_GetTopController
   -- could probably work out from mTitlePath (by getting first items mController)
   global gLCW
   put gLCW ["activeMenuArray"]["top"]["mController"] into mTopController
   return mTopController
end menu_GetTopController

command menu_IncludeMenuText @mText, insertedMenuTitle, targetObject, insertedMenuController, menuIsDisabled, pTitlePath, pTextPath, pMenuTarget
   -- recursive handler so be careful here to avoid infinite loops
   put menu_GetTable (insertedMenuTitle, insertedMenuController) into insertedMenuTable
   -- set the itemdelimiter to "/"
   -- delete item - 1 of pTitlePath
   put menu_ConvertTable (insertedMenuTable, targetObject, pTitlePath, pTextPath, pMenuTarget, menuIsDisabled) into insertedMenu
   if insertedMenu is not empty then put insertedMenu & CR after mText
   return empty
end menu_IncludeMenuText

command menu_InsertFixed @mText, mLine, pigeon, mController, paramProp, topMenuTarget, mItemType
   -- it's OK for there to be no submenu_Fixed getprop present and just get the objects custom property
   -- ignoreCall:  submenu_Fixed,g
   
   put mLine & CR after mText
   put word 1 of pigeon into mCommand
   put the submenu_Fixed [mCommand] of mController into subMenu
   if subMenu is not empty then
      menu_CheckSub subMenu, paramProp, mController, topMenuTarget, mItemType
      put text_Indent(subMenu) into subMenu
      put subMenu & CR after mText
   end if
end menu_InsertFixed

command menu_InsertSubMenu @mText, mLine, subMenuTitle, mView, subMenuController, pTitlePath, pTextPath, pMenuTarget, pSubMenuIsDisabled
   global gLCW
   
   put menu_GetTable (subMenuTitle, subMenuController) into mTable
   
   -- hack
   set the itemdelimiter to "/" 
   delete item -1 of pTitlePath
   put menu_ConvertTable (mTable, mView, pTitlePath, pTextPath, pMenuTarget, pSubMenuIsDisabled) into subMenu
   
   if subMenu is empty then
      -- don't do anything (ie also remove the submenu_Title "mLine"
   else
      put mLine & CR after mText
      put text_Indent (subMenu) into subMenu
      put subMenu & CR after mText
   end if
end menu_InsertSubMenu

function menu_MenuTextFromTitle mTitle
   set the itemdelimiter to "|"
   delete item - 1 of mTitle
   if word 1 to -1 of item 1 of mTitle = "Global" then delete item 1 of mTitle
   
   replace " | " with " " in mTitle
   return word 1 to -1 of mTitle
end menu_MenuTextFromTitle

command menu_SetActiveText mText
   global gLCW
   put mText into gLCW ["activeMenuArray"]["menu"]["text"]
end menu_SetActiveText

command menu_SetCheckedItem someMenuItem, @someMenu, someBoolean
    put someBoolean is not false into someBoolean
    put menu_GetLineNum (someMenuItem, someMenu) into lineNum
    if lineNum = 0 then return someMenu
     
    put menu_SetCheckedLine (lineNum, someMenu, someBoolean) into someMenu
end menu_SetCheckedItem

function menu_SetCheckedLine lineNum, someMenuText, someBoolean
   -- replace (return & "!c") with (return & "!n") in 
   
   put line lineNum of someMenuText into menuLine
   if someBoolean is true then 
      put "c" into checkValue
   else 
      put "n" into checkValue
   end if
   
   if char 1 of word 1 of menuLine is "!" then
      if char 2 of word 1 of menuLine is "n" then
         put checkValue into char 2 of word 1 of menuLine 
      else if char 2 of word 1 of menuLine is "c" then
         put checkValue into char 2 of word 1 of menuLine 
      else
         -- put checkValue into char 2 of word 1 of menuLine -- not sure
      end if
   else
      put "!" & checkValue before of word 1 menuLine 
   end if    
   put menuLine into line lineNum of someMenuText
   return someMenuText
end menu_SetCheckedLine

command menu_SetGlobalArray menuGlobalArray
   global gLCW
   put menuGlobalArray into gLCW ["Global Menus"]
   return gLCW ["Global Menus"]
end menu_SetGlobalArray

command menu_SetGlobalTable gMenuTitle, gMenuTable
   put menu_GetGlobalTitleArray (gMenuTitle) into gMenuTitleArray
   put gMenuTable into gMenuTitleArray ["gMenuTable"]
   menu_SetGlobalTitleArray gMenuTitle, gMenuTitleArray
   return mTitleTable
end menu_SetGlobalTable

command menu_SetGlobalTitleArray gMenuTitle, gMenuTitleArray
   put menu_GetGlobalArray() into menuGlobalArray
   put gMenuTitleArray into menuGlobalArray [gMenuTitle]
   menu_SetGlobalArray menuGlobalArray
   return gLCW
end menu_SetGlobalTitleArray

command menu_SetItemTargetOveride mItemToMatch, mTarget
   global gLCW
   put mTarget into gLCW ["activeMenuArray"]["overide"]["mItem"][mItemToMatch]["mTarget"]
end menu_SetItemTargetOveride

command menu_SetSentPath mPath
   global gLCW
   put mPath into gLCW ["activeMenuArray"]["sent"]["mPath"]
end menu_SetSentPath

command menu_SetTargetObject targetObject
   -- the target clicked on by the user
   global gLCW
   put targetObject into gLCW ["activeMenuArray"]["top"]["targetObject"]
end menu_SetTargetObject

command menu_SetTitlePath mTitlePath
   -- could be called "menu_SetSentTitlePath"
   global gLCW
   put mTitlePath into gLCW ["activeMenuArray"]["sent"]["mTitlePath"]
end menu_SetTitlePath

command menu_SetTopController mTopController
   global gLCW
   put mTopController into gLCW ["activeMenuArray"]["top"]["mController"]
end menu_SetTopController

function menu_TargetFromGlobal mPath
   -- used by "menu_ConvertTable" and "menu_SendMessage"
   
   put menu_TitlePathFromPath (mPath) into mTitlePath
   put menu_GetTopController() into mTopController
   
   -- removed "menu_GetTargetOveride"
   -- here we want to be able to change the mTarget depending on mTitlePath
   
   put the menu_Target [mTitlePath] of mTopController into mTarget
   if mTarget is not empty or mTarget is an array then
      put mTarget into gLCW ["activeMenuArray"]["top"]["mTarget"]
      return mTarget
   end if
   
   -- so go get a default!
   put menu_GetTargetObject() into targetObject
   put _GetDefaultMenuTarget (mPath, mTitlePath, targetObject) into mTarget
   put mTarget into gLCW ["activeMenuArray"]["top"]["mTarget"]
   return mTarget
end menu_TargetFromGlobal

function menu_TitleIsGlobal mTitle
   set the itemdelimiter to "|"
   return word 1 to -1 of item 1 of mTitle = "Global"
end menu_TitleIsGlobal

function menu_TitlePathFromPath mPath
   menu_DeconstructPath mPath, foundPath, subMenuPath, pigeon, mController, mTitlePath, mItemType
   return mTitlePath
end menu_TitlePathFromPath


--> Private
-
private command _addToMenuActiveArray mPath, mTitlePath, pigeon, mController, mView, mItemType, pMenuTarget
   if mPath is empty then return empty -- an insert?
   global gLCW
   
   if mItemType is among the items of "insert" then
      -- may need to disable a submenu, and need gLCW ["activeMenuArray"]to work out mTarget
      return empty
   end if
   if pMenuTarget is not empty then
      menu_SetItemTargetOveride mPath, pMenuTarget
   end if
   
   -- lets set work in progress mPath, mTitlePath so that submenus etc can use them to automatically gather context
   menu_SetTitlePath mTitlePath
   menu_SetSentPath mPath
   
   put pigeon into gLCW ["activeMenuArray"]["mPath"][mPath]["pigeon"]
   put mController into gLCW ["activeMenuArray"]["mPath"][mPath]["mController"]
   put mItemType into gLCW ["activeMenuArray"]["mPath"][mPath]["mItemType"]
   put mTitlePath into gLCW ["activeMenuArray"]["mPath"][mPath]["mTitlePath"]
   
   put mController into gLCW ["activeMenuArray"]["mTitlePath"][mTitlePath]["mController"]
   return empty
end _addToMenuActiveArray

private function _GetDefaultMenuTarget mPath, mTitlePath, targetObject
   -- a default can be dynamic and defined in the view using a "getprop menu_Target" handler
   put the menu_Target [mTitlePath] of targetObject into mTarget
   if mTarget is not empty then
      put mTarget into gLCW ["activeMenuArray"]["top"]["mTarget"]
      return mTarget -- could be something other than an object
   end if
   
   -- Finally if all else fails it returns the view or the target object.
   put view_FindAbove (targetObject) into someView -- to reduce dependency on view_Object
   -- put the view_Object of targetObject into someView
   
   if exists(someView) is false then put targetObject into someView
   return someView
end _GetDefaultMenuTarget

private command menu_TidyText @mText
   put word 1 to -1 of mText into mText
   
   -- remove double dividers
   replace (CR & "-" & CR & "-" & CR) with (CR & "-" & CR) in mText
   
   -- removes things like blank missing menu spaces
   repeat while (word 1 to -1 of line 1 of mText = "-")
      delete line 1 of mText
   end repeat
   repeat while (word 1 to -1 of line -1 of mText = "-")
      delete line -1 of mText
   end repeat
end menu_TidyText

private function text_Indent someText
   -- this is the minimal version of "outline_IncreaseIndent"
   repeat with lineNum = 1 to the number of lines of someText
      put tab before line lineNum of someText
   end repeat
   return someText
end text_Indent

private function view_FindAbove targetObject
   repeat
      if the uRIP ["type"] of targetObject is "view" then return targetObject
      if word 1 of targetObject = "group" and the selectGroupedControls of targetObject then return targetObject 
      if word 1 of targetObject = "stack" or targetObject = empty then return empty
      delete word 1 to 4 of targetObject -- does not work for substacks
   end repeat
   return empty
end view_FindAbove
